<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>堆排序</title>
</head>
<body>
  <p>
    堆排序(Heapsort) 是指利用堆这种数据结构锁设计的一种排序算法。
    堆积  是一个近似完全二叉树的结构, 并满足堆积的性质：即子节点的键值或索引总是小于或者大于他的父节点
  </p>
  <h3>算法描述和实现</h3>
  <p>具体算法描述如下：</p>
  <p>
    1.将初始待排序关键字序列(R1,R2...Rn)构建成大顶堆，此堆为初始的无序区;
    2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；
    3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

  </p>
  <p>代码实现:</p>
  <p>...</p>
  <p>
    3）算法分析

    最佳情况：T(n) = O(nlogn)
    最差情况：T(n) = O(nlogn)
    平均情况：T(n) = O(nlogn)
  </p>

  <script>
    function heapSort(array) {
      if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {
        //建堆
        var heapSize = array.length, temp;
        for(var i = Math.floor(heapSize/2) - 1; i >= 0; i--) {
          heapify(array, i, heapSize);
        }

        //堆排序
        for (var j = heapSize - 1; j >= 1; j--) {
          temp = array[0];
          array[0] = array[j];
          array[j] = temp;
          heapify(array, 0, --heapSize);
        }
        return array
      } else {
        return 'array is not an Array!';
      }
    }
    /*
    30000 数据 评价28ms
    /////
    默认sort: 30000 数据 评价25ms
    */
    function heapify(arr, x, len) {
      if(Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {
        var l = 2 * x + 1, r = 2 * x +2, largest = x, temp;
        if (l < len && arr[l] > arr[largest]) {
          largest = l;
        }
        if (r < len && arr[r] > arr[largest]) {
          largest = r;
        }
        if (largest != x) {
          temp = arr[x];
          arr[x] = arr[largest];
          arr[largest] = temp;
          heapify(arr,largest, len);
        }
      } else {
        return 'arr is not an Array or x is not a number !';
      }
    }
    let unSortArray = [];
    for(let i = 0,len= 30000;i < len;i++){
      unSortArray.push( Math.floor(Math.random()*10000) )
    }
    let startHeap = (new Date()).getTime();
    let sorted  = heapSort(unSortArray);
    console.log('heap'+ (new Date().getTime() - startHeap))
    console.log(sorted)
    let startDefault = (new Date()).getTime();
    let dSorted = unSortArray.sort(function(a,b){return a - b});
    console.log('default'+ (new Date().getTime() - startDefault))
    console.log(dSorted)
  </script>
</body>
</html>